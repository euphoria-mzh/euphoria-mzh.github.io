<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器网络 | Euphoria_MZH</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="https://aliyuncdn.antdv.com/v2/assets/logo.1ef800a8.svg">
    <meta name="description" content="想拥有一个完美的博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.b2a16f24.css" as="style"><link rel="preload" href="/assets/js/app.3034a2ae.js" as="script"><link rel="preload" href="/assets/js/3.8a392829.js" as="script"><link rel="preload" href="/assets/js/1.b8695b8b.js" as="script"><link rel="preload" href="/assets/js/58.02f18b82.js" as="script"><link rel="prefetch" href="/assets/js/10.676bef1a.js"><link rel="prefetch" href="/assets/js/11.2175373a.js"><link rel="prefetch" href="/assets/js/12.a4e236ab.js"><link rel="prefetch" href="/assets/js/13.9542231f.js"><link rel="prefetch" href="/assets/js/14.aa4cf985.js"><link rel="prefetch" href="/assets/js/15.5acc1b27.js"><link rel="prefetch" href="/assets/js/16.f5e97d2b.js"><link rel="prefetch" href="/assets/js/17.b68fd7da.js"><link rel="prefetch" href="/assets/js/18.7be5de17.js"><link rel="prefetch" href="/assets/js/19.94b992c6.js"><link rel="prefetch" href="/assets/js/20.f5626ee2.js"><link rel="prefetch" href="/assets/js/21.0766232a.js"><link rel="prefetch" href="/assets/js/22.dbe2cce6.js"><link rel="prefetch" href="/assets/js/23.a766af58.js"><link rel="prefetch" href="/assets/js/24.e1e9d343.js"><link rel="prefetch" href="/assets/js/25.066fe151.js"><link rel="prefetch" href="/assets/js/26.c912bcb2.js"><link rel="prefetch" href="/assets/js/27.d251f634.js"><link rel="prefetch" href="/assets/js/28.e20bd519.js"><link rel="prefetch" href="/assets/js/29.3d6326f7.js"><link rel="prefetch" href="/assets/js/30.4b69ebf4.js"><link rel="prefetch" href="/assets/js/31.4b24fab9.js"><link rel="prefetch" href="/assets/js/32.34e0b3ba.js"><link rel="prefetch" href="/assets/js/33.5d22c146.js"><link rel="prefetch" href="/assets/js/34.0fc8c1a3.js"><link rel="prefetch" href="/assets/js/35.7d0fabd5.js"><link rel="prefetch" href="/assets/js/36.4dd7595e.js"><link rel="prefetch" href="/assets/js/37.709afd6b.js"><link rel="prefetch" href="/assets/js/38.5697b11e.js"><link rel="prefetch" href="/assets/js/39.17ebd555.js"><link rel="prefetch" href="/assets/js/4.7ef01818.js"><link rel="prefetch" href="/assets/js/40.35a52045.js"><link rel="prefetch" href="/assets/js/41.89fe2f95.js"><link rel="prefetch" href="/assets/js/42.b16bb951.js"><link rel="prefetch" href="/assets/js/43.541595ba.js"><link rel="prefetch" href="/assets/js/44.9b43adaf.js"><link rel="prefetch" href="/assets/js/45.c8f7abe6.js"><link rel="prefetch" href="/assets/js/46.8b906b6a.js"><link rel="prefetch" href="/assets/js/47.1ec6859e.js"><link rel="prefetch" href="/assets/js/48.17062b9c.js"><link rel="prefetch" href="/assets/js/49.e82f56e8.js"><link rel="prefetch" href="/assets/js/5.06eb9adc.js"><link rel="prefetch" href="/assets/js/50.c36ff77f.js"><link rel="prefetch" href="/assets/js/51.d9ce6218.js"><link rel="prefetch" href="/assets/js/52.65ed3b4b.js"><link rel="prefetch" href="/assets/js/53.d63a0a76.js"><link rel="prefetch" href="/assets/js/54.8213d9a8.js"><link rel="prefetch" href="/assets/js/55.86af412f.js"><link rel="prefetch" href="/assets/js/56.13bcad5a.js"><link rel="prefetch" href="/assets/js/57.39c74f7a.js"><link rel="prefetch" href="/assets/js/59.bd4b7dcd.js"><link rel="prefetch" href="/assets/js/6.90d2da83.js"><link rel="prefetch" href="/assets/js/7.58ba9b77.js"><link rel="prefetch" href="/assets/js/8.5126035f.js"><link rel="prefetch" href="/assets/js/9.67731a54.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b2a16f24.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-6f8f7dda><div data-v-6f8f7dda><div class="password-shadow password-wrapper-out" style="display:none;" data-v-f68096de data-v-6f8f7dda data-v-6f8f7dda><h3 class="title" data-v-f68096de>Euphoria_MZH</h3> <p class="description" data-v-f68096de>想拥有一个完美的博客</p> <label id="box" class="inputBox" data-v-f68096de><input type="password" value="" data-v-f68096de> <span data-v-f68096de>Konck! Knock!</span> <button data-v-f68096de>OK</button></label> <div class="footer" data-v-f68096de><span data-v-f68096de><i class="iconfont reco-theme" data-v-f68096de></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-f68096de>vuePress-theme-reco</a></span> <span data-v-f68096de><i class="iconfont reco-copyright" data-v-f68096de></i> <a data-v-f68096de><span data-v-f68096de>温</span>
          
        <span data-v-f68096de>2020 - </span>
        2023
      </a></span></div></div> <div class="hide" data-v-6f8f7dda><header class="navbar" data-v-6f8f7dda><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://aliyuncdn.antdv.com/v2/assets/logo.1ef800a8.svg" alt="Euphoria_MZH" class="logo"> <span class="site-name">Euphoria_MZH</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-WEBqianduan"></i>
      前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/前端/HTML/" class="nav-link"><i class="iconfont icon-html"></i>
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/前端/CSS/" class="nav-link"><i class="iconfont icon-css3"></i>
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/前端/Javascript/" class="nav-link"><i class="iconfont icon-JavaScript"></i>
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/前端/Typescript/" class="nav-link"><i class="iconfont icon-ts"></i>
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/前端/Vue/" class="nav-link"><i class="iconfont icon-Vue"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/前端/React/" class="nav-link"><i class="iconfont icon-React"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/前端/uniapp/" class="nav-link"><i class="iconfont icon-uni-app"></i>
  Uni-app
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-houduankaifa"></i>
      后端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/后端/node/" class="nav-link"><i class="iconfont icon-node"></i>
  Node
</a></li><li class="dropdown-item"><!----> <a href="/后端/Java/" class="nav-link"><i class="iconfont icon-java"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/后端/Python/" class="nav-link"><i class="iconfont icon-python"></i>
  Python
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-wendang"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>组件库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/文档/组件库/element.html" class="nav-link"><i class="iconfont icon-element"></i>
  Element
</a></li><li class="dropdown-subitem"><a href="/文档/组件库/antd.html" class="nav-link"><i class="iconfont icon-antdesign"></i>
  Antd
</a></li><li class="dropdown-subitem"><a href="/文档/组件库/vant.html" class="nav-link"><i class="iconfont icon-bootstrap"></i>
  Vant
</a></li></ul></li><li class="dropdown-item"><h4>第三方库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/文档/第三方库/jquery.html" class="nav-link"><i class="iconfont icon-jQuery"></i>
  Jquery
</a></li><li class="dropdown-subitem"><a href="/文档/第三方库/bootstrap.html" class="nav-link"><i class="iconfont icon-bootstrap"></i>
  Bootstrap
</a></li></ul></li><li class="dropdown-item"><h4>框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/文档/框架/Electron.html" class="nav-link"><i class="iconfont icon-electron"></i>
  Electron
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-icongongju"></i>
      常用工具
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>管理工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/常用工具/管理工具/Linux.html" class="nav-link"><i class="iconfont icon-linux"></i>
  Linux
</a></li><li class="dropdown-subitem"><a href="/常用工具/管理工具/git.html" class="nav-link"><i class="iconfont icon-git"></i>
  Git
</a></li><li class="dropdown-subitem"><a href="/常用工具/管理工具/npm.html" class="nav-link"><i class="iconfont icon-npm"></i>
  Npm
</a></li><li class="dropdown-subitem"><a href="/常用工具/管理工具/yarn.html" class="nav-link"><i class="iconfont icon-yarn"></i>
  Yarn
</a></li><li class="dropdown-subitem"><a href="/常用工具/管理工具/markdown.html" class="nav-link"><i class="iconfont icon-markdown"></i>
  Markdown
</a></li></ul></li><li class="dropdown-item"><h4>常用软件</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/常用工具/常用软件/数据库.html" class="nav-link"><i class="iconfont icon-database-full"></i>
  数据库
</a></li><li class="dropdown-subitem"><a href="/常用工具/常用软件/云服务器.html" class="nav-link"><i class="iconfont icon-yunfuwuqi1"></i>
  云服务器
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-jiaocheng"></i>
      实用教程
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/实用教程/Windows/" class="nav-link"><i class="iconfont icon-windows"></i>
  Windows
</a></li><li class="dropdown-item"><!----> <a href="/实用教程/Mac/" class="nav-link"><i class="iconfont icon-mac"></i>
  Mac
</a></li><li class="dropdown-item"><!----> <a href="/实用教程/效率工具/" class="nav-link"><i class="iconfont icon-xiaoshuai"></i>
  效率工具
</a></li><li class="dropdown-item"><!----> <a href="/实用教程/第三方包/" class="nav-link"><i class="iconfont icon-xiaoshuai"></i>
  实用第三方包
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-wendang"></i>
      算法和数据结构
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/算法和数据结构/算法/" class="nav-link"><i class="iconfont icon-suanfaku"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/算法和数据结构/数据结构/" class="nav-link"><i class="iconfont icon-shujujiegou"></i>
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/算法和数据结构/面试题库/" class="nav-link"><i class="iconfont icon-mianshitiku"></i>
  面试题库
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-shenghuo"></i>
      生活
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/生活/美食/" class="nav-link"><i class="iconfont icon-airudiantubiaohuizhi-zhuanqu_meishicaipu"></i>
  美食
</a></li><li class="dropdown-item"><!----> <a href="/music.html" class="nav-link"><i class="iconfont icon-wangyiyunyinle"></i>
  音乐
</a></li><li class="dropdown-item"><!----> <a href="/生活/游戏/" class="nav-link"><i class="iconfont icon-youxi"></i>
  游戏
</a></li><li class="dropdown-item"><!----> <a href="/生活/壁纸/" class="nav-link"><i class="iconfont icon-tupian"></i>
  壁纸
</a></li><li class="dropdown-item"><!----> <a href="/生活/视频/" class="nav-link"><i class="iconfont icon-shipin"></i>
  视频
</a></li></ul></div></div><div class="nav-item"><a href="/about-me.html" class="nav-link"><i class="iconfont reco-account"></i>
  关于
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-6f8f7dda></div> <aside class="sidebar" data-v-6f8f7dda><div class="personal-info-wrapper" data-v-1600d2ca data-v-6f8f7dda><img src="https://euphoria-mzh-1306939841.cos.ap-hongkong.myqcloud.com/ava.png" alt="author-avatar" class="personal-img" data-v-1600d2ca> <h3 class="name" data-v-1600d2ca>
    温
  </h3> <h4 class="jianjie" data-v-1600d2ca>前端开发工程师</h4> <div class="num" data-v-1600d2ca><div data-v-1600d2ca><h3 data-v-1600d2ca>47</h3> <h6 data-v-1600d2ca>文章</h6></div> <div data-v-1600d2ca><h3 data-v-1600d2ca>12</h3> <h6 data-v-1600d2ca>分类</h6></div> <div data-v-1600d2ca><h3 data-v-1600d2ca>30</h3> <h6 data-v-1600d2ca>标签</h6></div></div> <ul class="social-links" data-v-1600d2ca><li class="social-item" data-v-1600d2ca><i class="iconfont reco-github" style="color:#67cc86;" data-v-1600d2ca></i></li><li class="social-item" data-v-1600d2ca><i class="iconfont reco-mayun" style="color:#f26d6d;" data-v-1600d2ca></i></li><li class="social-item" data-v-1600d2ca><i class="iconfont reco-douyin" style="color:#65c9d6;" data-v-1600d2ca></i></li><li class="social-item" data-v-1600d2ca><i class="iconfont reco-qq" style="color:#67cc86;" data-v-1600d2ca></i></li></ul> <hr data-v-1600d2ca></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-WEBqianduan"></i>
      前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/前端/HTML/" class="nav-link"><i class="iconfont icon-html"></i>
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/前端/CSS/" class="nav-link"><i class="iconfont icon-css3"></i>
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/前端/Javascript/" class="nav-link"><i class="iconfont icon-JavaScript"></i>
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/前端/Typescript/" class="nav-link"><i class="iconfont icon-ts"></i>
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/前端/Vue/" class="nav-link"><i class="iconfont icon-Vue"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/前端/React/" class="nav-link"><i class="iconfont icon-React"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/前端/uniapp/" class="nav-link"><i class="iconfont icon-uni-app"></i>
  Uni-app
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-houduankaifa"></i>
      后端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/后端/node/" class="nav-link"><i class="iconfont icon-node"></i>
  Node
</a></li><li class="dropdown-item"><!----> <a href="/后端/Java/" class="nav-link"><i class="iconfont icon-java"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/后端/Python/" class="nav-link"><i class="iconfont icon-python"></i>
  Python
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-wendang"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>组件库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/文档/组件库/element.html" class="nav-link"><i class="iconfont icon-element"></i>
  Element
</a></li><li class="dropdown-subitem"><a href="/文档/组件库/antd.html" class="nav-link"><i class="iconfont icon-antdesign"></i>
  Antd
</a></li><li class="dropdown-subitem"><a href="/文档/组件库/vant.html" class="nav-link"><i class="iconfont icon-bootstrap"></i>
  Vant
</a></li></ul></li><li class="dropdown-item"><h4>第三方库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/文档/第三方库/jquery.html" class="nav-link"><i class="iconfont icon-jQuery"></i>
  Jquery
</a></li><li class="dropdown-subitem"><a href="/文档/第三方库/bootstrap.html" class="nav-link"><i class="iconfont icon-bootstrap"></i>
  Bootstrap
</a></li></ul></li><li class="dropdown-item"><h4>框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/文档/框架/Electron.html" class="nav-link"><i class="iconfont icon-electron"></i>
  Electron
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-icongongju"></i>
      常用工具
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>管理工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/常用工具/管理工具/Linux.html" class="nav-link"><i class="iconfont icon-linux"></i>
  Linux
</a></li><li class="dropdown-subitem"><a href="/常用工具/管理工具/git.html" class="nav-link"><i class="iconfont icon-git"></i>
  Git
</a></li><li class="dropdown-subitem"><a href="/常用工具/管理工具/npm.html" class="nav-link"><i class="iconfont icon-npm"></i>
  Npm
</a></li><li class="dropdown-subitem"><a href="/常用工具/管理工具/yarn.html" class="nav-link"><i class="iconfont icon-yarn"></i>
  Yarn
</a></li><li class="dropdown-subitem"><a href="/常用工具/管理工具/markdown.html" class="nav-link"><i class="iconfont icon-markdown"></i>
  Markdown
</a></li></ul></li><li class="dropdown-item"><h4>常用软件</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/常用工具/常用软件/数据库.html" class="nav-link"><i class="iconfont icon-database-full"></i>
  数据库
</a></li><li class="dropdown-subitem"><a href="/常用工具/常用软件/云服务器.html" class="nav-link"><i class="iconfont icon-yunfuwuqi1"></i>
  云服务器
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-jiaocheng"></i>
      实用教程
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/实用教程/Windows/" class="nav-link"><i class="iconfont icon-windows"></i>
  Windows
</a></li><li class="dropdown-item"><!----> <a href="/实用教程/Mac/" class="nav-link"><i class="iconfont icon-mac"></i>
  Mac
</a></li><li class="dropdown-item"><!----> <a href="/实用教程/效率工具/" class="nav-link"><i class="iconfont icon-xiaoshuai"></i>
  效率工具
</a></li><li class="dropdown-item"><!----> <a href="/实用教程/第三方包/" class="nav-link"><i class="iconfont icon-xiaoshuai"></i>
  实用第三方包
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-wendang"></i>
      算法和数据结构
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/算法和数据结构/算法/" class="nav-link"><i class="iconfont icon-suanfaku"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/算法和数据结构/数据结构/" class="nav-link"><i class="iconfont icon-shujujiegou"></i>
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/算法和数据结构/面试题库/" class="nav-link"><i class="iconfont icon-mianshitiku"></i>
  面试题库
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont icon-shenghuo"></i>
      生活
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/生活/美食/" class="nav-link"><i class="iconfont icon-airudiantubiaohuizhi-zhuanqu_meishicaipu"></i>
  美食
</a></li><li class="dropdown-item"><!----> <a href="/music.html" class="nav-link"><i class="iconfont icon-wangyiyunyinle"></i>
  音乐
</a></li><li class="dropdown-item"><!----> <a href="/生活/游戏/" class="nav-link"><i class="iconfont icon-youxi"></i>
  游戏
</a></li><li class="dropdown-item"><!----> <a href="/生活/壁纸/" class="nav-link"><i class="iconfont icon-tupian"></i>
  壁纸
</a></li><li class="dropdown-item"><!----> <a href="/生活/视频/" class="nav-link"><i class="iconfont icon-shipin"></i>
  视频
</a></li></ul></div></div><div class="nav-item"><a href="/about-me.html" class="nav-link"><i class="iconfont reco-account"></i>
  关于
</a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试题库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/" aria-current="page" class="sidebar-link">面试题库</a></li><li><a href="/算法和数据结构/面试题库/css.html" class="sidebar-link">CSS</a></li><li><a href="/算法和数据结构/面试题库/html.html" class="sidebar-link">Html</a></li><li><a href="/算法和数据结构/面试题库/js.html" class="sidebar-link">JavaScript</a></li><li><a href="/算法和数据结构/面试题库/react.html" class="sidebar-link">React</a></li><li><a href="/算法和数据结构/面试题库/vue.html" class="sidebar-link">Vue</a></li><li><a href="/算法和数据结构/面试题库/浏览器网络.html" class="active sidebar-link">浏览器网络</a></li><li><a href="/算法和数据结构/面试题库/项目.html" class="sidebar-link">项目方面</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-f68096de data-v-6f8f7dda><h3 class="title" data-v-f68096de>浏览器网络</h3> <!----> <label id="box" class="inputBox" data-v-f68096de><input type="password" value="" data-v-f68096de> <span data-v-f68096de>Konck! Knock!</span> <button data-v-f68096de>OK</button></label> <div class="footer" data-v-f68096de><span data-v-f68096de><i class="iconfont reco-theme" data-v-f68096de></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-f68096de>vuePress-theme-reco</a></span> <span data-v-f68096de><i class="iconfont reco-copyright" data-v-f68096de></i> <a data-v-f68096de><span data-v-f68096de>温</span>
          
        <span data-v-f68096de>2020 - </span>
        2023
      </a></span></div></div> <div data-v-6f8f7dda><div data-v-6f8f7dda><main class="page"><section style="display:;"><div class="page-title" style="background:url(/images/14.jpg) center/cover no-repeat;"><h1 class="title">浏览器网络</h1> <div data-v-1e62957f><i class="iconfont reco-account" data-v-1e62957f><span data-v-1e62957f>温</span></i> <i class="iconfont reco-date" data-v-1e62957f><span data-v-1e62957f>5/29/2020</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1e62957f><span class="tag-item" data-v-1e62957f>面试</span></i></div></div> <div class="theme-reco-content content__default"><div class="custom-block tip"><p class="title"></p><p>浏览器网络面试题</p></div> <h1 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h1> <h2 id="从输入url到页面加载的全过程"><a href="#从输入url到页面加载的全过程" class="header-anchor">#</a> 从输入URL到页面加载的全过程</h2> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44aa8a92602405db3c12161b71e2094~tplv-k3u1fbpfcp-zoom-1.image" alt="从输入URL到页面加载的主干流程"></p> <ol><li><p>首先在浏览器中输入URL</p></li> <li><p>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p> <ul><li>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</li> <li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</li> <li>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</li> <li>ISP缓存：若上述均失败，继续向ISP搜索。</li></ul></li> <li><p>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议</code>。</p></li> <li><p>建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</p></li> <li><p>发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器</p></li> <li><p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p></li> <li><p>关闭TCP连接：通过四次挥手释放TCP连接</p></li> <li><p>浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：</p> <ul><li>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li> <li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li> <li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li> <li>布局（Layout）：计算出每个节点在屏幕中的位置</li> <li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90660027f0d4c559732519bad4c6323~tplv-k3u1fbpfcp-zoom-1.image" alt="浏览器渲染流程图"></p></li> <li><p>JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p> <ul><li>创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</li> <li>加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</li> <li>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</li> <li>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。</li></ul></li></ol> <p>传送门 ☞ <a href="https://juejin.cn/post/7005468491067162655" target="_blank" rel="noopener noreferrer"># DNS域名解析过程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ☞<a href="https://juejin.cn/post/6992597760935460901" target="_blank" rel="noopener noreferrer"># 浏览器的工作原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="在浏览器中输入url到显示页面经历哪些过程-涉及到哪些协议"><a href="#在浏览器中输入url到显示页面经历哪些过程-涉及到哪些协议" class="header-anchor">#</a> 在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？</h2> <p>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议。</code></p> <p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p> <p>其中：</p> <p>1、<code>DNS协议，http协议，https协议属于应用层</code></p> <p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p> <p>2、<code>TCP/UDP属于传输层</code></p> <p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p> <p>3、<code>IP协议，ARP协议属于网络层</code></p> <p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。</p> <p>4、数据链路层</p> <p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。</p> <p>5、物理层</p> <p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p> <h2 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="header-anchor">#</a> 浏览器的主要功能</h2> <p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p> <h2 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="header-anchor">#</a> 浏览器的工作原理</h2> <p>渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p> <p>然后进行如下所示的基本流程：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ef6cb226b374e89914a2315e4ca9ba9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>图：渲染引擎的基本流程。</p> <p>渲染引擎将开始<code>解析 HTML 文档</code>，并将各标记逐个转化成“内容树”上的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F%23DOM" title="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#DOM" target="_blank" rel="noopener noreferrer">DOM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 节点。同时也会<code>解析外部 CSS 文件以及样式元素中的样式数据</code>。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F%23Render_tree_construction" title="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Render_tree_construction" target="_blank" rel="noopener noreferrer"><code>渲染树</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p> <p>渲染树构建完毕之后，进入“<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F%23layout" title="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#layout" target="_blank" rel="noopener noreferrer">布局<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F%23Painting" title="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Painting" target="_blank" rel="noopener noreferrer">绘制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> - 渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。</p> <p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</p> <h2 id="浏览器的主要组成部分是什么"><a href="#浏览器的主要组成部分是什么" class="header-anchor">#</a> 浏览器的主要组成部分是什么？</h2> <ol><li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li> <li><strong>浏览器引擎</strong> - 在用户界面和呈现引擎之间传送指令。</li> <li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li> <li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li> <li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li> <li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li> <li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f83cb61cb9de4a65abeb95e50608af48~tplv-k3u1fbpfcp-watermark.awebp" alt=""></li></ol> <p>图：浏览器的主要组件。</p> <p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p> <h2 id="浏览器是如何渲染ui的"><a href="#浏览器是如何渲染ui的" class="header-anchor">#</a> 浏览器是如何渲染UI的？</h2> <ol><li>浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree</li> <li>与此同时，进行CSS解析，生成Style Rules</li> <li>接着将DOM Tree与Style Rules合成为 Render Tree</li> <li>接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标</li> <li>随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来</li></ol> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67b1336692f540c9a81756f93e82c2f5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h2 id="dom-tree是如何构建的"><a href="#dom-tree是如何构建的" class="header-anchor">#</a> DOM Tree是如何构建的？</h2> <ol><li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串</li> <li>生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens</li> <li>构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope</li> <li>生成DOM Tree: 通过node包含的指针确定的关系构建出DOM<br>
Tree</li></ol> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dc0f577836c4705bb582b2ac15bc5d1~tplv-k3u1fbpfcp-zoom-1.image" alt="2019-06-22-11-48-00"></p> <h2 id="浏览器重绘与重排的区别"><a href="#浏览器重绘与重排的区别" class="header-anchor">#</a> 浏览器重绘与重排的区别？</h2> <ul><li><code>重排/回流（Reflow）</code>：当<code>DOM</code>的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li> <li><code>重绘(Repaint)</code>: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</li></ul> <p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p> <p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p> <p>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</p> <h2 id="如何触发重排和重绘"><a href="#如何触发重排和重绘" class="header-anchor">#</a> 如何触发重排和重绘？</h2> <p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p> <ul><li>添加、删除、更新DOM节点</li> <li>通过display: none隐藏一个DOM节点-触发重排和重绘</li> <li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li> <li>移动或者给页面中的DOM节点添加动画</li> <li>添加一个样式表，调整样式属性</li> <li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul> <h2 id="如何避免重绘或者重排"><a href="#如何避免重绘或者重排" class="header-anchor">#</a> 如何避免重绘或者重排？</h2> <ol><li><p><code>集中改变样式</code>，不要一条一条地修改 DOM 的样式。</p></li> <li><p>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</p></li> <li><p>为动画的 HTML 元件使用 <code>fixed</code> 或 <code>absoult</code> 的 <code>position</code>，那么修改他们的 CSS 是不会 reflow 的。</p></li> <li><p>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p></li> <li><p>尽量只修改<code>position：absolute</code>或<code>fixed</code>元素，对其他元素影响不大</p></li> <li><p>动画开始<code>GPU</code>加速，<code>translate</code>使用<code>3D</code>变化</p></li> <li><p>提升为合成层</p> <p>将元素提升为合成层有以下优点：</p> <ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li> <li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li> <li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul> <p>提升合成层的最好方式是使用 CSS 的 will-change 属性：</p> <div class="language- extra-class"><pre class="language-text"><code>#target {
  will-change: transform;
}
</code></pre></div><blockquote><p>关于合成层的详解请移步<a href="https://link.juejin.cn?target=http%3A%2F%2Ftaobaofed.org%2Fblog%2F2016%2F04%2F25%2Fperformance-composite%2F" title="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noopener noreferrer">无线性能优化：Composite<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote></li></ol> <h2 id="介绍下304过程"><a href="#介绍下304过程" class="header-anchor">#</a> 介绍下304过程</h2> <ul><li>a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。</li> <li>b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。</li> <li>c. 协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</li></ul> <h2 id="浏览器的缓存机制-强制缓存-协商缓存"><a href="#浏览器的缓存机制-强制缓存-协商缓存" class="header-anchor">#</a> 浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h2> <p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/487144abaada4b9a8b34bc9375191ec7~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p> <p>由上图我们可以知道：</p> <ul><li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li> <li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li></ul> <p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p> <ul><li><p><strong>强制缓存</strong></p> <p><code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中Cache-Control优先级比Expires高。</p> <p>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p> <ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li> <li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li> <li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol></li> <li><p><strong>协商缓存</strong></p> <p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：</p> <ol><li>协商缓存生效，返回304</li> <li>协商缓存失效，返回200和请求结果结果</li></ol></li></ul> <p>传送门 ☞ <a href="https://juejin.cn/post/6992843117963509791" target="_blank" rel="noopener noreferrer"># 彻底理解浏览器的缓存机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="cookie、sessionstorage、localstorage-的区别"><a href="#cookie、sessionstorage、localstorage-的区别" class="header-anchor">#</a> Cookie、sessionStorage、localStorage 的区别</h2> <p><strong>相同点</strong>：</p> <ul><li>存储在客户端</li></ul> <p><strong>不同点</strong>：</p> <ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li> <li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li> <li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ul> <h2 id="说下进程、线程和协程"><a href="#说下进程、线程和协程" class="header-anchor">#</a> 说下进程、线程和协程</h2> <p><strong>进程</strong>是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<code>是操作系统进行资源分配和调度的一个独立单位</code>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p> <p><strong>线程</strong>是程序执行中一个单一的顺序控制流程，是<code>程序执行流的最小单元</code>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p> <p><strong>协程</strong>，英文Coroutines，是一种<code>基于线程之上，但又比线程更加轻量级的存在</code>，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p> <p><strong>进程和线程的区别与联系</strong></p> <p>【区别】：</p> <p>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</p> <p>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p> <p>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p> <p>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p> <p>【联系】：</p> <p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p> <p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p> <p>处理机分给线程，即真正在处理机上运行的是线程；</p> <p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p> <p>传送门 ☞ <a href="https://juejin.cn/post/7005465381791875109" target="_blank" rel="noopener noreferrer"># 一文搞懂进程、线程、协程及JS协程的发展<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="http://www.360doc.com/content/20/0417/14/32196507_906628857.shtml" target="_blank" rel="noopener noreferrer">☞了解更多<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>关于浏览器传送门 ☞<a href="https://juejin.cn/post/6993095345576083486" target="_blank" rel="noopener noreferrer"># 深入了解现代 Web 浏览器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="header-anchor">#</a> 进程间的通信方式</h2> <p><code>进程通信</code>：
每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。</p> <p>进程间的通信方式：管道、有名管道、信号、消息队列、共享内存、信号量、socket</p> <p><code>匿名管道( pipe )</code>： 管道是一种半双工的通信方式，数据只能<strong>单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指<strong>父子进程关系</strong>。</p> <p><code>高级管道(popen)</code>：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p> <p><code>有名管道 (named pipe)</code>： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p> <p><code>消息队列( message queue )</code> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p> <p><code>信号量( semophore )</code> ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p> <p><code>信号 ( sinal )</code> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p> <p><code>共享内存( shared memory )</code> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p> <p><code>套接字( socket ) 通信</code>： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信</p> <h2 id="浏览器样式兼容"><a href="#浏览器样式兼容" class="header-anchor">#</a> 浏览器样式兼容</h2> <h3 id="一、css初始化"><a href="#一、css初始化" class="header-anchor">#</a> 一、CSS初始化</h3> <p>每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是对其进行初始化（覆盖默认样式）</p> <blockquote><p>常见 :  *{ margin: 0; padding: 0;}</p> <p>库：normalize.css</p></blockquote> <h3 id="二、浏览器私有属性"><a href="#二、浏览器私有属性" class="header-anchor">#</a> 二、<strong>浏览器私有属性</strong></h3> <blockquote><p>常用的前缀有：</p> <p>firefox浏览器 ：-moz-</p> <p>chrome、safari ：-webkit-</p> <p>opera ：-o- / -xv-</p> <p>IE浏览器 ：-ms-（目前只有 IE 8+支持）</p></blockquote> <h3 id="三、css-hack-条件hack、属性级hack、选择符级hack"><a href="#三、css-hack-条件hack、属性级hack、选择符级hack" class="header-anchor">#</a> <strong>三、CSS hack（条件hack、属性级hack、选择符级hack）</strong></h3> <h2 id="js垃圾回收机制"><a href="#js垃圾回收机制" class="header-anchor">#</a> JS垃圾回收机制</h2> <ol><li><p>项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。</p></li> <li><p>浏览器垃圾回收机制/内存回收机制:</p> <blockquote><p>浏览器的<code>Javascript</code>具有自动垃圾回收机制(<code>GC:Garbage Collecation</code>)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p></blockquote> <p><strong>标记清除</strong>:在<code>js</code>中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间。<br> <strong>谷歌浏览器</strong>：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。<br> <strong>IE浏览器</strong>：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。</p></li> <li><p>优化手段：内存优化 ; 手动释放：取消内存的占用即可。</p> <p>（1）堆内存：fn = null 【null：空指针对象】</p> <p>（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</p></li> <li><p>内存泄漏</p> <p>在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</p></li></ol> <h1 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h1> <h2 id="http-的基本概念"><a href="#http-的基本概念" class="header-anchor">#</a> HTTP 的基本概念</h2> <p>http: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端<code>请求和应答的标准（TCP）</code>，用于从 WWW 服务器传输超文本到本地浏览器的<code>超文本传输协议</code>。</p> <h2 id="http工作原理"><a href="#http工作原理" class="header-anchor">#</a> HTTP工作原理</h2> <p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。客户端向服务器发送一个请求报文，服务器以一个状态行作为响应。</p> <h2 id="http请求-响应的步骤"><a href="#http请求-响应的步骤" class="header-anchor">#</a> HTTP请求/响应的步骤</h2> <ul><li>1.客户端连接到Web服务器</li> <li>2.发送HTTP请求</li> <li>3.服务器接受请求并返回HTTP响应</li> <li>4.释放TCP连接</li> <li>5.客户端（浏览器）解析HTML内容</li></ul> <blockquote><p>记忆口诀：连接发送加响应，释放解析整过程。</p></blockquote> <h2 id="http-的-5-种方法"><a href="#http-的-5-种方法" class="header-anchor">#</a> HTTP 的 5 种方法</h2> <ul><li>GET---获取资源</li> <li>POST---传输资源</li> <li>PUT---更新资源</li> <li>DELETE---删除资源</li> <li>HEAD---获取报文首部</li></ul> <h2 id="get与post的区别"><a href="#get与post的区别" class="header-anchor">#</a> GET与POST的区别</h2> <p><strong>1.浏览器回退表现不同</strong> GET在浏览器回退时是无害的，而POST会再次提交请求
<strong>2.浏览器对请求地址的处理不同</strong> GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置
<strong>3.浏览器对响应的处理不同</strong>GET请求参数会被完整的保留在浏览器历史记录里，而POST中的参数不会被保留
<strong>4.参数大小不同.</strong> GET请求在URL中传送的参数是有长度的限制，而POST没有限制
<strong>5.安全性不同.</strong> GET参数通过URL传递，会暴露，不安全；POST放在Request Body中，相对更安全
<strong>6.针对数据操作的类型不同</strong>.GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。</p> <h2 id="http报文的组成成分"><a href="#http报文的组成成分" class="header-anchor">#</a> HTTP报文的组成成分</h2> <p>请求报文{ 请求行、请求头、空行、请求体 } 请求行：{http方法、页面地址、http协议、http版本} 响应报文{ 状态行、响应头、空行、响应体 }</p> <p><strong>Request Header:</strong></p> <ol><li><strong>GET /sample.Jsp HTTP/1.1</strong>  //请求行</li> <li><strong>Host:</strong>  www.uuid.online/ //请求的目标域名和端口号</li> <li><strong>Origin:</strong> http://localhost:8081/  //请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）</li> <li><strong>Referer:</strong> https://localhost:8081/link?query=xxxxx //请求资源的完整URI</li> <li><strong>User-Agent:</strong> Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 //浏览器信息</li> <li><strong>Cookie:</strong>  BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0  //当前域名下的Cookie</li> <li><strong>Accept:</strong> text/html,image/apng  //代表客户端希望接受的数据类型是html或者是png图片类型</li> <li><strong>Accept-Encoding:</strong> gzip, deflate  //代表客户端能支持gzip和deflate格式的压缩</li> <li><strong>Accept-Language:</strong> zh-CN,zh;q=0.9  //代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)</li> <li><strong>Connection:</strong> keep-alive  //告诉服务器，客户端需要的tcp连接是一个长连接</li></ol> <p><strong>Response Header:</strong></p> <ol><li><strong>HTTP/1.1 200 OK</strong>  // 响应状态行</li> <li><strong>Date:</strong>  Mon, 30 Jul 2018 02:50:55 GMT  //服务端发送资源时的服务器时间</li> <li><strong>Expires:</strong>  Wed, 31 Dec 1969 23:59:59 GMT //比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页</li> <li><strong>Cache-Control:</strong>  no-cache  // 现在最多使用的控制缓存的方式，会和服务器进行缓存验证，具体见<a href="https://www.cnblogs.com/amiezhang/p/9389537.html" target="_blank" rel="noopener noreferrer">博文”Cache-Control“<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><strong>etag:</strong>  &quot;fb8ba2f80b1d324bb997cbe188f28187-ssl-df&quot;  // 一般是<a href="http://www.t086.com/article/5207" target="_blank" rel="noopener noreferrer">Nginx静态服务器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>发来的静态文件签名，浏览在没有“Disabled cache”情况下，接收到etag后，同一个url第二次请求就会自动带上“If-None-Match”</li> <li><strong>Last-Modified:</strong>  Fri, 27 Jul 2018 11:04:55 GMT //是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容</li> <li><strong>Content-Type:</strong>  text/html; charset=utf-8  //如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码</li> <li><strong>Content-Encoding:</strong>  gzip  //告诉客户端，应该采用gzip对资源进行解码</li> <li><strong>Connection:</strong>  keep-alive  //告诉客户端服务器的tcp连接也是一个长连接</li></ol> <h2 id="https-的基本概念"><a href="#https-的基本概念" class="header-anchor">#</a> https 的基本概念</h2> <p>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。</p> <p>https 协议的作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p> <h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="header-anchor">#</a> http 和 https 的区别？</h2> <ul><li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li> <li>Https 协议需要 ca 证书，费用较高。</li> <li>使用不同的链接方式，端口也不同，一般，http 协议的端口为 80，https 的端口为 443。</li> <li>http 的连接很简单，是无状态的。</li></ul> <blockquote><p>记忆口诀：明文传输超文本，安全等级各不同。CA证书费用高，无状连接端难同。</p></blockquote> <h3 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="header-anchor">#</a> https 协议的工作原理</h3> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42bc6f45451457fa6d614fb27534516~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p> <p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p> <ol><li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li> <li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li> <li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li> <li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li> <li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li> <li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li></ol> <blockquote><p>记忆口诀：一连二传三协商，四建五得六使用。</p></blockquote> <h3 id="https-协议的优缺点"><a href="#https-协议的优缺点" class="header-anchor">#</a> https 协议的优缺点</h3> <ul><li>HTTPS 协议要比 http 协议<code>安全</code>，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</li> <li>https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li> <li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li> <li>SSL 证书也需要钱，功能越强大的<code>证书费</code>用越高。</li> <li>SSL 证书需要绑定 <code>IP</code>，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li></ul> <h2 id="tcp-ip网络模型"><a href="#tcp-ip网络模型" class="header-anchor">#</a> TCP/IP网络模型</h2> <p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p> <ul><li>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li> <li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li> <li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li> <li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li></ul> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa80b3b48a84bd18d8e708c56a1dc22~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <h2 id="tcp三次握手"><a href="#tcp三次握手" class="header-anchor">#</a> TCP三次握手</h2> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf3d5df95a74f47a1d779ee50c3411f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p> <ol><li>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</li> <li>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack=j+1），<code>同时也发送一个自己的SYN包</code>（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li> <li>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。
</code></pre></div><h2 id="tcp-四次挥手"><a href="#tcp-四次挥手" class="header-anchor">#</a> TCP 四次挥手</h2> <ol><li><code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li></ol> <p>2）<code>服务器收到连接释放报文，发出确认报文</code>，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p> <p>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p> <p>4）<code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p> <p>5）<code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p> <p>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p> <h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="header-anchor">#</a> TCP和UDP的区别</h2> <ol><li><p>TCP是面向<code>连接</code>的，而UDP是面向无连接的。</p></li> <li><p>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</p></li> <li><p>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</p></li> <li><p>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</p></li></ol> <h2 id="http-请求跨域问题"><a href="#http-请求跨域问题" class="header-anchor">#</a> HTTP 请求跨域问题</h2> <ol><li><p>跨域的原理</p> <p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。<br> <strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br> <strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p></li> <li><p>解决方案</p> <p>最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</p> <ul><li><p><strong>JSONP</strong>：<br>
ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p> <p>步骤：</p> <ol><li>去创建一个script标签</li> <li>script的src属性设置接口地址</li> <li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li> <li>通过定义函数名去接受返回的数据</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//动态创建 script</span>
<span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 设置回调函数</span>
<span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//设置 script 的 src 属性，并设置请求地址</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3000/?callback=getData'</span><span class="token punctuation">;</span>

<span class="token comment">// 让 script 生效</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>JSONP 的缺点</strong>:<br>
JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p></li> <li><p><strong>document.domain</strong>  基础域名相同 子域名不同</p></li> <li><p><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</p></li> <li><p><strong>CORS</strong> CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></li> <li><p><strong>proxy代理</strong> 目前常用方式</p></li> <li><p><strong>window.postMessage()</strong>  利用h5新特性 window.postMessage()</p></li> <li><p><strong>Websocket</strong></p></li></ul></li></ol> <h2 id="cookie、sessionstorage、localstorage-的区别-2"><a href="#cookie、sessionstorage、localstorage-的区别-2" class="header-anchor">#</a> Cookie、sessionStorage、localStorage 的区别</h2> <p><strong>相同点</strong>：</p> <ul><li>存储在客户端</li></ul> <p><strong>不同点</strong>：</p> <ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li> <li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li> <li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ul> <h2 id="http状态码及常见状态码"><a href="#http状态码及常见状态码" class="header-anchor">#</a> HTTP状态码及常见状态码</h2> <h3 id="http状态码"><a href="#http状态码" class="header-anchor">#</a> HTTP状态码</h3> <ul><li>1xx：指示信息类，表示请求已接受，继续处理</li> <li>2xx：指示成功类，表示请求已成功接受</li> <li>3xx：指示重定向，表示要完成请求必须进行更近一步的操作</li> <li>4xx：指示客户端错误，请求有语法错误或请求无法实现</li> <li>5xx：指示服务器错误，服务器未能实现合法的请求</li></ul> <h3 id="常见状态码"><a href="#常见状态码" class="header-anchor">#</a> 常见状态码</h3> <ul><li><p>200 OK：客户端请求成功</p></li> <li><p>301 Moved Permanently：所请求的页面已经永久重定向至新的URL</p></li> <li><p>302 Found：所请求的页面已经临时重定向至新的URL</p></li> <li><p>304 Not Modified 未修改。</p></li> <li><p>403 Forbidden：对请求页面的访问被禁止</p></li> <li><p>404 Not Found：请求资源不存在</p></li> <li><p>500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用</p></li> <li><p>503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常</p></li> <li><p>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码</p> <ul><li>100 - 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分</li> <li>101 - 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换</li></ul></li> <li><p>2xx（成功）表示成功处理了请求的状态码</p> <ul><li><code>200</code> - 成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页</li> <li>201 - 已创建 请求成功并且服务器创建了新的资源</li> <li>202 - 已接受 服务器已接受请求，但尚未处理</li> <li>203 - 非授权信息 服务器已经成功处理了请求，但返回的信息可能来自另一来源</li> <li>204 - 无内容 服务器成功处理了请求，但没有返回任何内容</li> <li>205 - 重置内容 服务器成功处理了请求，但没有返回任何内容</li></ul></li> <li><p>3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向</p> <ul><li>300 - 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择</li> <li><code>301</code> - 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置</li> <li><code>302</code> - 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li> <li>303 - 查看其它位置 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码</li> <li><code>304</code> - 未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容</li> <li>305 - 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理</li> <li><code>307</code> - 临时性重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求</li></ul></li> <li><p>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理</p> <ul><li><code>400</code> - 错误请求 服务器不理解请求的语法</li> <li><code>401</code> - 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li> <li><code>403</code> - 禁止 服务器拒绝请求</li> <li><code>404</code> - 未找到 服务器找不到请求的网页</li> <li>405 - 方法禁用 禁用请求中指定的方法</li> <li>406 - 不接受 无法使用请求的内容特性响应请求的网页</li> <li><code>407</code> - 需要代理授权 此状态码与401（未授权）类似，但指定请求者应当授权使用代理</li> <li><code>408</code> - 请求超时 服务器等候请求时发生超时</li> <li>410 - 已删除 如果请求的资源已永久删除，服务器就会返回此响应</li> <li><code>413</code> - 请求实体过大 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力</li> <li><code>414</code> - 请求的URI过长 请求的URI（通常为网址）过长，服务器无法处理</li></ul></li> <li><p>5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错</p> <ul><li><code>500</code> - 服务器内部错误 服务器遇到错误，无法完成请求</li> <li>501 - 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li> <li><code>502</code> - 错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应</li> <li><code>503</code> - 服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态</li> <li><code>504</code> - 网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求</li> <li>505 - HTTP版本不受支持 服务器不支持请求中所用的HTTP协议版本</li></ul></li></ul> <h2 id="介绍下304过程-2"><a href="#介绍下304过程-2" class="header-anchor">#</a> 介绍下304过程</h2> <ul><li><p>a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。</p></li> <li><p>b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。</p></li> <li><p>c. 协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p></li></ul> <h2 id="浏览器的缓存机制-强制缓存-协商缓存-2"><a href="#浏览器的缓存机制-强制缓存-协商缓存-2" class="header-anchor">#</a> 浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h2> <p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b3fe9c411f4881a8b22fe37eae170b~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p> <p>由上图我们可以知道：</p> <ul><li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li> <li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li></ul> <p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p> <ul><li><p><strong>强制缓存</strong></p> <p><code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中Cache-Control优先级比Expires高。</p> <p>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p> <ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li> <li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li> <li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol></li> <li><p><strong>协商缓存</strong></p> <p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：</p> <ol><li>协商缓存生效，返回304</li> <li>协商缓存失效，返回200和请求结果结果</li></ol></li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e0ce991db4847b98d9f049f9ffa5c93~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p> <p>传送门 ☞ <a href="https://juejin.cn/post/6992843117963509791" title="https://juejin.cn/post/6992843117963509791" target="_blank" rel="noopener noreferrer"># 彻底理解浏览器的缓存机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="http-请求跨域问题-2"><a href="#http-请求跨域问题-2" class="header-anchor">#</a> HTTP 请求跨域问题</h2> <ol><li><p>跨域的原理</p> <p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。跨域访问是被各大浏览器所默认禁止的。<br> <strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br> <strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p></li> <li><p>解决方案</p> <p>最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</p> <ul><li><p><strong>JSONP</strong>：<br>
ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p> <p>步骤：</p> <ol><li>去创建一个script标签</li> <li>script的src属性设置接口地址</li> <li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li> <li>通过定义函数名去接受返回的数据</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//动态创建 script</span>
<span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 设置回调函数</span>
<span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//设置 script 的 src 属性，并设置请求地址</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3000/?callback=getData'</span><span class="token punctuation">;</span>

<span class="token comment">// 让 script 生效</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>JSONP 的缺点</strong>:<br>
JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p></li> <li><p><strong>document.domain</strong> 基础域名相同 子域名不同</p></li> <li><p><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p></li> <li><p><strong>CORS</strong>
CORS(Cross-origin resource sharing)跨域资源共享 是一种机制，是目前主流的跨域解决方案，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p> <p>1.浏览器端会自动向请求头添加origin字段，表明当前请求来源。<br>
2.服务器设置Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers等 HTTP响应头字段之后，浏览器将会允许跨域请求。</p> <p><strong>预检</strong></p> <p>但是还有复杂一点的请求，我们需要先发OPTIONS请求，a.com想请求b.com它需要发一个自定义的Headers：X-ABC和content-type，这个时候就不是简单请求了， a.com要给b.com 发一个options请求，它其实在问b.com我用post行不行，还想在Headers中带X-ABC和content-type；并不是所有的headers都发这个OPTIONS请求，因为X-ABC是自定义的，所以需要发；b.com看到OPTIONS请求，先不会返回数据，先检查自己的策略，看看能不能支持这次请求，如果支持就返回200。</p> <p>OPTIONS请求返回以下报文</p> <p>HTTP/2.0 20 OK
Access-Control-Allow-Origin:https://a.com
Access-Control-Allow-Methods:POST,GET,OPTIONS
Access-Control-Allow-Headers:X-ABC,Content-Type
Access-Control-Max-Age:86400 // 告诉浏览器这个策略生效时间为一个小时，在一个小时之内发送类似的请求，不用在问服务端了，相当于缓存了
浏览器收到了OPTIONS的返回，会在发一次，这一次才是真正的请求数据，这次headers会带上X-ABC、contentType。</p> <p>整体的过程cors将请求分为2种，简单请求和复杂请求，需不需要发送OPTIONS浏览器说的算，浏览器判断是简单请求还是复杂请求，cors是非常广泛的跨域手段 这里的缺点是OPTIONS请求也是一次请求，消耗带宽，真正的请求也会延迟。</p></li> <li><p>最方便的跨域方案 <strong>proxy代理+ Nginx</strong>
nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</p> <p>跨域问题的产生是因为浏览器的同源政策造成的，但是服务器与服务器之间的数据交换是没有这个限制。</p> <p>反向代理就是采用这种方式，建立一个虚拟的代理服务器来接收 internet 上的链接请求，然后转发给内部网络上的服务器，并将从服务器上得到的结果，返回给 internet 上请求链接的客户端。现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。</p></li> <li><p><strong>window.postMessage()</strong> 利用h5新特性window.postMessage()</p></li></ul></li></ol> <p>跨域传送门 ☞ <a href="https://juejin.cn/post/7003232769182547998" target="_blank" rel="noopener noreferrer"># 跨域，不可不知的基础概念<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="header-anchor">#</a> 粘包问题分析与对策</h2> <p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p> <p><strong>粘包出现原因</strong></p> <p>简单得说，在流传输中出现，UDP不会出现粘包，因为它有<strong>消息边界</strong></p> <p>粘包情况有两种，一种是<code>粘在一起的包都是完整的数据包</code>，另一种情况是<code>粘在一起的包有不完整的包</code>。</p> <p>为了<strong>避免粘包</strong>现象，可采取以下几种措施：</p> <p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，<code>TCP提供了强制数据立即传送的操作指令push</code>，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p> <p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、<code>提高接收进程优先级等措施</code>，使其及时接收数据，从而尽量避免出现粘包现象；</p> <p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<code>分包多发</code>。</p> <p>以上提到的三种措施，都有其不足之处。</p> <p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p> <p>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</p> <p>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p> <blockquote><p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</p></blockquote> <h2 id="客户端与服务端长连接的几种方式"><a href="#客户端与服务端长连接的几种方式" class="header-anchor">#</a> 客户端与服务端长连接的几种方式</h2> <ol><li><p><strong>ajax 轮询</strong> <strong>实现原理</strong>：ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。</p> <p><strong>优点</strong>：可实现基础（指间隔时间较短）的数据更新。</p> <p><strong>缺点</strong>：这种方法也只是尽量的模拟即时传输，但并非真正意义上的即时通讯，很有可能出现客户端请求时，服务端数据并未更新。或者服务端数据已更新，但客户端未发起请求。导致多次请求资源浪费，效率低下。【<code>数据更新不及时，效率低下</code>】</p></li> <li><p><strong>long poll 长轮询</strong></p> <p><strong>实现原理</strong>：
long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询。在 HTTP1.0 中客户端可以设置请求头 Connection:keep-alive，服务端收到该请求头之后知道这是一个长连接，在响应报文头中也添加 Connection:keep-alive。客户端收到之后表示长连接建立完成，可以继续发送其他的请求。在 HTTP1.1 中默认使用了 Connection:keep-alive 长连接。</p> <p><strong>优点</strong>：减少客户端的请求，降低无效的网络传输，保证每次请求都有数据返回，不会一直占用线程。</p> <p><strong>缺点</strong>：无法处理高并发，当客户端请求量大，请求频繁时对服务器的处理能力要求较高。服务器一直保持连接会消耗资源，需要同时维护多个线程，服务器所能承载的 TCP 连接数是有上限的，这种轮询很容易把连接数顶满。每次通讯都需要客户端发起，服务端不能主动推送。【<code>无法处理高并发，消耗服务器资源严重，服务端不能主动推送</code>】</p></li> <li><p><strong>iframe 长连接</strong></p> <p><strong>实现原理：</strong><br>
在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。</p> <p><strong>优点</strong>：消息及时传输。</p> <p><strong>缺点</strong>：<code>消耗服务器资源</code>。</p></li> <li><p><strong>WebSocket</strong></p> <p><strong>实现原理</strong>：
Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。</p> <p>Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。</p> <p>Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。</p> <p><strong>优点</strong>：
双向通信。客户端和服务端双方都可以主动发起通讯。
没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。
数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。
传输效率高。因为只需要一次连接，所以数据传输效率高。</p> <p><strong>缺点</strong>：
长连接需要后端处理业务的代码更稳定，推送消息相对复杂；<br>
长连接受网络限制比较大，需要处理好重连。<br>
兼容性，WebSocket 只支持 IE10 及其以上版本。<br>
服务器长期维护长连接需要一定的成本，各个浏览器支持程度不一；<br>
成熟的 HTTP 生态下有大量的组件可以复用，WebSocket 则没有，遇到异常问题难以快速定位快速解决。【需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小】</p></li></ol> <h2 id="利用socket建立网络连接的步骤"><a href="#利用socket建立网络连接的步骤" class="header-anchor">#</a> 利用Socket建立网络连接的步骤</h2> <p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。</p> <p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p> <p>1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p> <p>2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。</p> <p>为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p> <p>3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。</p> <p>而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p> <h2 id="非对称加密rsa"><a href="#非对称加密rsa" class="header-anchor">#</a> 非对称加密RSA</h2> <p>简介：</p> <ol><li>对称加密算法又称现代加密算法。</li> <li>非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。</li> <li>非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey)</li> <li>公开密钥和私有密钥是一对</li></ol> <p>如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。 
如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。</p> <p>特点： 
算法强度复杂，安全性依赖于算法与密钥。 
加密解密速度慢。</p> <p>与对称加密算法的对比： 
对称加密只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。 
非对称加密有两种密钥，其中一个是公开的。</p> <p>RSA应用场景： 
由于RSA算法的加密解密速度要比对称算法速度慢很多，在实际应用中，通常采取 
数据本身的加密和解密使用对称加密算法(AES)。 用RSA算法加密并传输对称算法所需的密钥。</p> <h2 id="http1、http2、http3"><a href="#http1、http2、http3" class="header-anchor">#</a> HTTP1、HTTP2、HTTP3</h2> <p>HTTP/2 相比于 HTTP/1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，虽如此但HTTP/2并非完美的，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。</p> <h2 id="http1-1-的缺陷"><a href="#http1-1-的缺陷" class="header-anchor">#</a> <strong>HTTP1.1 的缺陷</strong></h2> <ol><li><p>高延迟 — 队头阻塞(Head-Of-Line Blocking)</p> <p><code>队头阻塞</code>是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。</p> <p>针对队头阻塞的解决办法:</p> <ul><li><code>将同一页面的资源分散到不同域名下，提升连接上限</code>。</li> <li><code>合并小文件减少资源数</code>，使用精灵图。</li> <li><code>内联(Inlining)资源</code>是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。</li> <li><code>减少请求数量</code>，合并文件。</li></ul></li> <li><p>无状态特性 — 阻碍交互</p> <p><code>无状态是指协议对于连接状态没有记忆能力</code>。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。</p> <p><code>Header里携带的内容过大，在一定程度上增加了传输的成本</code>。且请求响应报文里有大量字段值都是重复的。</p></li> <li><p>明文传输 — 不安全性</p> <p>HTTP/1.1在传输数据时，所有<code>传输的内容都是明文</code>，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。</p></li> <li><p>不支持服务端推送</p></li></ol> <blockquote><p>记忆口诀：队头阻塞高延迟，无状态阻交互，明文传输不安全，服务推送不支持。</p></blockquote> <p><strong>HTTP 1.1 排队问题</strong></p> <p>HTTP 1.1多个文件共用一个TCP，这样可以减少tcp握手，这样3个文件就不用握手9次了，不过这样请求文件需要排队，请求和返回都需要排队， 如果第一个文件响应慢，会阻塞后面的文件，这样就产生了对头的等待问题。</p> <p>有的网站可能会有很多文件，浏览器处于对机器性能的考虑，它不可能让你无限制的发请求建连接，因为建立连接需要占用资源，浏览器不想把用户的网络资源都占用了，所以浏览器最多会建立6个tcp连接；如果有上百个文件可能都需要排队，http2.0正在解决这个问题。</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ecdc60670194df7957ee59e1f56701f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p> <h2 id="spdy-协议与-http-2-简介"><a href="#spdy-协议与-http-2-简介" class="header-anchor">#</a> SPDY 协议与 HTTP/2 简介</h2> <h3 id="_1、http-2-简介"><a href="#_1、http-2-简介" class="header-anchor">#</a> 1、HTTP/2 简介</h3> <p>HTTP/2是现行HTTP协议（HTTP/1.x）的替代，但它不是重写。<strong>HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）</strong> 。</p> <h3 id="_2、http-2-新特性"><a href="#_2、http-2-新特性" class="header-anchor">#</a> 2、HTTP/2 新特性</h3> <h3 id="_1、二进制传输"><a href="#_1、二进制传输" class="header-anchor">#</a> 1、二进制传输</h3> <p><code>HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩</code>。我们先来介绍二进制传输,HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。<code>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</code>。</p> <h3 id="_2、header-压缩"><a href="#_2、header-压缩" class="header-anchor">#</a> 2、Header 压缩</h3> <p>HTTP/2并没有使用传统的压缩算法，而是开发了专门的&quot;HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p> <h3 id="_3、多路复用"><a href="#_3、多路复用" class="header-anchor">#</a> 3、多路复用</h3> <p>在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输。</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f756ad3403bc4fe18e970c56677c796e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p> <h3 id="_4、server-push"><a href="#_4、server-push" class="header-anchor">#</a> 4、Server Push</h3> <p>HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。减少等待的延迟，这被称为&quot;<code>服务器推送</code>&quot;（ Server Push，也叫 Cache push）</p> <h3 id="_5、提高安全性"><a href="#_5、提高安全性" class="header-anchor">#</a> 5、提高安全性</h3> <p>出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</p> <p>但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，<strong>所以“事实上”的HTTP/2是加密的</strong>。也就是说，互联网上通常所能见到的HTTP/2都是使用&quot;https”协议名，跑在TLS上面。HTTP/2协议定义了两个字符串标识符：“h2&quot;表示加密的HTTP/2，“h2c”表示明文的HTTP/2。</p> <h3 id="_6、防止对头阻塞"><a href="#_6、防止对头阻塞" class="header-anchor">#</a> 6、防止对头阻塞</h3> <p>http1.1如果第一个文件阻塞，第二个文件也就阻塞了。</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b67bd1f793a3425d9e8a415cae9b7863~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p> <p>http2.0的解决，把3个请求打包成一个小块发送过去，即使第一个阻塞了，后面2个也可以回来；相当于3个文件同时请求，就看谁先回来谁后回来，阻塞的可能就后回来，对带宽的利用是最高的；但没有解决TCP的对头阻塞，如果TCP发过去的一个分包发丢了，他会重新发一次；http2.0的解决了大文件的阻塞。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d8ae8e0de44f3aa693f0626a346d4c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p> <p>一个分包请求3个文件，即使第一个阻塞了，第二个也能返回</p> <h2 id="http-2-的缺点"><a href="#http-2-的缺点" class="header-anchor">#</a> HTTP/2 的缺点</h2> <p>虽然 HTTP/2 解决了很多之前旧版本的问题，但它还是存在一个巨大的问题，<strong>主要是底层支撑的 TCP 协议造成的</strong>。HTTP/2的缺点主要有以下几点：</p> <ol><li>TCP 以及 TCP+TLS 建立连接时延时</li> <li>TCP 的队头阻塞并没有彻底解决</li> <li>多路复用导致服务器压力上升也容易 Timeout</li></ol> <h2 id="http-3-新特性"><a href="#http-3-新特性" class="header-anchor">#</a> HTTP/3 新特性</h2> <h3 id="_1、http-3简介"><a href="#_1、http-3简介" class="header-anchor">#</a> 1、HTTP/3简介</h3> <p>Google 在推SPDY的时候就搞了个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而“HTTP over QUIC”就是HTTP/3，真正“完美”地解决了“队头阻塞”问题。</p> <p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。</p> <h3 id="_2、quic新功能"><a href="#_2、quic新功能" class="header-anchor">#</a> 2、QUIC新功能</h3> <p>QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流&quot;是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：</p> <ul><li><p><strong>实现了类似TCP的流量控制、传输可靠性的功能</strong></p> <p>虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p></li> <li><p><strong>实现了快速握手功能</strong></p> <p>由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong>。</p></li> <li><p><strong>集成了TLS加密功能</strong></p></li> <li><p><strong>多路复用，彻底解决TCP中队头阻塞的问题</strong></p> <p>和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。</p></li> <li><p><strong>连接迁移</strong></p> <p>TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。</p></li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li>HTTP/1.1有两个主要的缺点：安全不足和性能不高。</li> <li>HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS&quot;，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li> <li>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</li></ul> <h2 id="理解xss-csrf-ddos攻击原理以及避免方式"><a href="#理解xss-csrf-ddos攻击原理以及避免方式" class="header-anchor">#</a> 理解xss，csrf，ddos攻击原理以及避免方式</h2> <p><code>XSS</code>(<code>Cross-Site Scripting</code>，<strong>跨站脚本攻击</strong>)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 <code>cookie，session tokens</code>，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p> <p><code>CSRF</code>（<code>Cross-site request forgery</code>）<strong>跨站请求伪造</strong>：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p> <p><strong>XSS避免方式：</strong></p> <ol><li><code>url</code>参数使用<code>encodeURIComponent</code>方法转义</li> <li>尽量不是有<code>InnerHtml</code>插入<code>HTML</code>内容</li> <li>使用特殊符号、标签转义符。</li></ol> <p><code>CSRF</code>避免方式：</p> <ol><li><p>添加验证码</p></li> <li><p>使用token</p> <ul><li>服务端给用户生成一个token，加密后传递给用户</li> <li>用户在提交请求时，需要携带这个token</li> <li>服务端验证token是否正确</li></ul></li></ol> <p><code>DDoS</code>又叫分布式拒绝服务，全称 <code>Distributed Denial of Service</code>，其原理就是利用大量的请求造成资源过载，导致服务不可用。</p> <p><strong><code>DDos</code>避免方式：</strong></p> <ol><li>限制单IP请求频率。</li> <li>防火墙等防护设置禁止<code>ICMP</code>包等</li> <li>检查特权端口的开放</li></ol> <p><a href="https://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&amp;mid=2247487116&amp;idx=1&amp;sn=09187eeb7e45faa1bee86ff48ae14be1&amp;source=41#wechat_redirect" target="_blank" rel="noopener noreferrer">360技术：嗨，送你一张Web性能优化地图<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/算法和数据结构/面试题库/vue.html" class="prev">
          Vue
        </a></span> <span class="next"><a href="/算法和数据结构/面试题库/项目.html">
          项目方面
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-6986a797 data-v-6f8f7dda><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#从输入url到页面加载的全过程" class="sidebar-link reco-side-从输入url到页面加载的全过程" data-v-6986a797>从输入URL到页面加载的全过程</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#在浏览器中输入url到显示页面经历哪些过程-涉及到哪些协议" class="sidebar-link reco-side-在浏览器中输入url到显示页面经历哪些过程-涉及到哪些协议" data-v-6986a797>在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#浏览器的主要功能" class="sidebar-link reco-side-浏览器的主要功能" data-v-6986a797>浏览器的主要功能</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#浏览器的工作原理" class="sidebar-link reco-side-浏览器的工作原理" data-v-6986a797>浏览器的工作原理</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#浏览器的主要组成部分是什么" class="sidebar-link reco-side-浏览器的主要组成部分是什么" data-v-6986a797>浏览器的主要组成部分是什么？</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#浏览器是如何渲染ui的" class="sidebar-link reco-side-浏览器是如何渲染ui的" data-v-6986a797>浏览器是如何渲染UI的？</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#dom-tree是如何构建的" class="sidebar-link reco-side-dom-tree是如何构建的" data-v-6986a797>DOM Tree是如何构建的？</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#浏览器重绘与重排的区别" class="sidebar-link reco-side-浏览器重绘与重排的区别" data-v-6986a797>浏览器重绘与重排的区别？</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#如何触发重排和重绘" class="sidebar-link reco-side-如何触发重排和重绘" data-v-6986a797>如何触发重排和重绘？</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#如何避免重绘或者重排" class="sidebar-link reco-side-如何避免重绘或者重排" data-v-6986a797>如何避免重绘或者重排？</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#介绍下304过程" class="sidebar-link reco-side-介绍下304过程" data-v-6986a797>介绍下304过程</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#浏览器的缓存机制-强制缓存-协商缓存" class="sidebar-link reco-side-浏览器的缓存机制-强制缓存-协商缓存" data-v-6986a797>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#cookie、sessionstorage、localstorage-的区别" class="sidebar-link reco-side-cookie、sessionstorage、localstorage-的区别" data-v-6986a797>Cookie、sessionStorage、localStorage 的区别</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#说下进程、线程和协程" class="sidebar-link reco-side-说下进程、线程和协程" data-v-6986a797>说下进程、线程和协程</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#进程间的通信方式" class="sidebar-link reco-side-进程间的通信方式" data-v-6986a797>进程间的通信方式</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#浏览器样式兼容" class="sidebar-link reco-side-浏览器样式兼容" data-v-6986a797>浏览器样式兼容</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#一、css初始化" class="sidebar-link reco-side-一、css初始化" data-v-6986a797>一、CSS初始化</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#二、浏览器私有属性" class="sidebar-link reco-side-二、浏览器私有属性" data-v-6986a797>二、浏览器私有属性</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#三、css-hack-条件hack、属性级hack、选择符级hack" class="sidebar-link reco-side-三、css-hack-条件hack、属性级hack、选择符级hack" data-v-6986a797>三、CSS hack（条件hack、属性级hack、选择符级hack）</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#js垃圾回收机制" class="sidebar-link reco-side-js垃圾回收机制" data-v-6986a797>JS垃圾回收机制</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http-的基本概念" class="sidebar-link reco-side-http-的基本概念" data-v-6986a797>HTTP 的基本概念</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http工作原理" class="sidebar-link reco-side-http工作原理" data-v-6986a797>HTTP工作原理</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http请求-响应的步骤" class="sidebar-link reco-side-http请求-响应的步骤" data-v-6986a797>HTTP请求/响应的步骤</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http-的-5-种方法" class="sidebar-link reco-side-http-的-5-种方法" data-v-6986a797>HTTP 的 5 种方法</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#get与post的区别" class="sidebar-link reco-side-get与post的区别" data-v-6986a797>GET与POST的区别</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http报文的组成成分" class="sidebar-link reco-side-http报文的组成成分" data-v-6986a797>HTTP报文的组成成分</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#https-的基本概念" class="sidebar-link reco-side-https-的基本概念" data-v-6986a797>https 的基本概念</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http-和-https-的区别" class="sidebar-link reco-side-http-和-https-的区别" data-v-6986a797>http 和 https 的区别？</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#https-协议的工作原理" class="sidebar-link reco-side-https-协议的工作原理" data-v-6986a797>https 协议的工作原理</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#https-协议的优缺点" class="sidebar-link reco-side-https-协议的优缺点" data-v-6986a797>https 协议的优缺点</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#tcp-ip网络模型" class="sidebar-link reco-side-tcp-ip网络模型" data-v-6986a797>TCP/IP网络模型</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#tcp三次握手" class="sidebar-link reco-side-tcp三次握手" data-v-6986a797>TCP三次握手</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#tcp-四次挥手" class="sidebar-link reco-side-tcp-四次挥手" data-v-6986a797>TCP 四次挥手</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#tcp和udp的区别" class="sidebar-link reco-side-tcp和udp的区别" data-v-6986a797>TCP和UDP的区别</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http-请求跨域问题" class="sidebar-link reco-side-http-请求跨域问题" data-v-6986a797>HTTP 请求跨域问题</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#cookie、sessionstorage、localstorage-的区别-2" class="sidebar-link reco-side-cookie、sessionstorage、localstorage-的区别-2" data-v-6986a797>Cookie、sessionStorage、localStorage 的区别</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http状态码及常见状态码" class="sidebar-link reco-side-http状态码及常见状态码" data-v-6986a797>HTTP状态码及常见状态码</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http状态码" class="sidebar-link reco-side-http状态码" data-v-6986a797>HTTP状态码</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#常见状态码" class="sidebar-link reco-side-常见状态码" data-v-6986a797>常见状态码</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#介绍下304过程-2" class="sidebar-link reco-side-介绍下304过程-2" data-v-6986a797>介绍下304过程</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#浏览器的缓存机制-强制缓存-协商缓存-2" class="sidebar-link reco-side-浏览器的缓存机制-强制缓存-协商缓存-2" data-v-6986a797>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http-请求跨域问题-2" class="sidebar-link reco-side-http-请求跨域问题-2" data-v-6986a797>HTTP 请求跨域问题</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#粘包问题分析与对策" class="sidebar-link reco-side-粘包问题分析与对策" data-v-6986a797>粘包问题分析与对策</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#客户端与服务端长连接的几种方式" class="sidebar-link reco-side-客户端与服务端长连接的几种方式" data-v-6986a797>客户端与服务端长连接的几种方式</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#利用socket建立网络连接的步骤" class="sidebar-link reco-side-利用socket建立网络连接的步骤" data-v-6986a797>利用Socket建立网络连接的步骤</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#非对称加密rsa" class="sidebar-link reco-side-非对称加密rsa" data-v-6986a797>非对称加密RSA</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http1、http2、http3" class="sidebar-link reco-side-http1、http2、http3" data-v-6986a797>HTTP1、HTTP2、HTTP3</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http1-1-的缺陷" class="sidebar-link reco-side-http1-1-的缺陷" data-v-6986a797>HTTP1.1 的缺陷</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#spdy-协议与-http-2-简介" class="sidebar-link reco-side-spdy-协议与-http-2-简介" data-v-6986a797>SPDY 协议与 HTTP/2 简介</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#_1、http-2-简介" class="sidebar-link reco-side-_1、http-2-简介" data-v-6986a797>1、HTTP/2 简介</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#_2、http-2-新特性" class="sidebar-link reco-side-_2、http-2-新特性" data-v-6986a797>2、HTTP/2 新特性</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#_1、二进制传输" class="sidebar-link reco-side-_1、二进制传输" data-v-6986a797>1、二进制传输</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#_2、header-压缩" class="sidebar-link reco-side-_2、header-压缩" data-v-6986a797>2、Header 压缩</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#_3、多路复用" class="sidebar-link reco-side-_3、多路复用" data-v-6986a797>3、多路复用</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#_4、server-push" class="sidebar-link reco-side-_4、server-push" data-v-6986a797>4、Server Push</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#_5、提高安全性" class="sidebar-link reco-side-_5、提高安全性" data-v-6986a797>5、提高安全性</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#_6、防止对头阻塞" class="sidebar-link reco-side-_6、防止对头阻塞" data-v-6986a797>6、防止对头阻塞</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http-2-的缺点" class="sidebar-link reco-side-http-2-的缺点" data-v-6986a797>HTTP/2 的缺点</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#http-3-新特性" class="sidebar-link reco-side-http-3-新特性" data-v-6986a797>HTTP/3 新特性</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#_1、http-3简介" class="sidebar-link reco-side-_1、http-3简介" data-v-6986a797>1、HTTP/3简介</a></li><li class="level-3" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#_2、quic新功能" class="sidebar-link reco-side-_2、quic新功能" data-v-6986a797>2、QUIC新功能</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#总结" class="sidebar-link reco-side-总结" data-v-6986a797>总结</a></li><li class="level-2" data-v-6986a797><a href="/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C.html#理解xss-csrf-ddos攻击原理以及避免方式" class="sidebar-link reco-side-理解xss-csrf-ddos攻击原理以及避免方式" data-v-6986a797>理解xss，csrf，ddos攻击原理以及避免方式</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.3034a2ae.js" defer></script><script src="/assets/js/3.8a392829.js" defer></script><script src="/assets/js/1.b8695b8b.js" defer></script><script src="/assets/js/58.02f18b82.js" defer></script>
  </body>
</html>
