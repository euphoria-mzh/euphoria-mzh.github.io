(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{528:function(a,t,r){"use strict";r.r(t);var e=r(2),s=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"}),t("p",[a._v("常见数据结构总结")])]),t("h2",{attrs:{id:"线性数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线性数据结构"}},[a._v("#")]),a._v(" 线性数据结构")]),a._v(" "),t("h3",{attrs:{id:"数组-array"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组-array"}},[a._v("#")]),a._v(" 数组（Array）")]),a._v(" "),t("p",[a._v("数组是一种简单的线性数据结构，它由相同类型的元素组成，并通过下标来访问每个元素。在内存中，这些元素被连续地存储在一段连续的地址空间中。由于这种特性，数组具有随机访问的能力，可以在O(1)的时间复杂度内访问任意元素。但是，插入和删除操作比较低效，需要移动其他元素。")]),a._v(" "),t("h3",{attrs:{id:"链表-linked-list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表-linked-list"}},[a._v("#")]),a._v(" 链表（Linked List）")]),a._v(" "),t("p",[a._v("链表也是一种线性数据结构，它由节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。链表的元素不需要在内存中连续存储，它们可以分散在内存中的任意位置。由于这种特性，链表具有高效的插入和删除操作，只需要改变指针即可完成，时间复杂度为O(1)。但是，访问任意元素需要遍历整个链表，时间复杂度为O(n)。")]),a._v(" "),t("p",[a._v("链表有多种形式，包括单向链表、双向链表、循环链表等。")]),a._v(" "),t("h3",{attrs:{id:"栈-stack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈-stack"}},[a._v("#")]),a._v(" 栈（Stack）")]),a._v(" "),t("p",[a._v("栈是一种后进先出（LIFO）的线性数据结构，它只允许在栈顶进行插入和删除操作。栈可以用数组或链表实现。栈常用于表达式求值、函数调用、浏览器前进后退等场景。")]),a._v(" "),t("h3",{attrs:{id:"队列-queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列-queue"}},[a._v("#")]),a._v(" 队列（Queue）")]),a._v(" "),t("p",[a._v("队列是一种先进先出（FIFO）的线性数据结构，它只允许在队尾进行插入操作，在队头进行删除操作。队列可以用数组或链表实现。队列常用于任务调度、消息传递等场景。")]),a._v(" "),t("h3",{attrs:{id:"双端队列-deque"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双端队列-deque"}},[a._v("#")]),a._v(" 双端队列（Deque）")]),a._v(" "),t("p",[a._v("双端队列是一种允许在队头和队尾进行插入和删除操作的线性数据结构。双端队列可以用数组或链表实现。双端队列常用于滑动窗口问题等场景。")]),a._v(" "),t("h3",{attrs:{id:"向量-vector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#向量-vector"}},[a._v("#")]),a._v(" 向量（Vector）")]),a._v(" "),t("p",[a._v("向量是一种动态数组，它是一个能够自动扩容的数组。向量在数组的基础上增加了自动扩容的功能，当数组大小达到一定阈值时，向量会自动申请更大的内存空间，并将原数组元素拷贝到新数组中。向量常用于存储动态增长的数据集合。")]),a._v(" "),t("h2",{attrs:{id:"非线性数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非线性数据结构"}},[a._v("#")]),a._v(" 非线性数据结构")]),a._v(" "),t("h3",{attrs:{id:"树-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树-tree"}},[a._v("#")]),a._v(" 树（Tree）")]),a._v(" "),t("p",[a._v("树是一种非线性数据结构，它由节点组成，每个节点包含一个数据元素和若干指向子节点的指针。树的节点可以有多个子节点，但每个子节点只有一个父节点。树可以用于表示目录结构、XML解析等场景。")]),a._v(" "),t("h4",{attrs:{id:"二叉树-binary-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉树-binary-tree"}},[a._v("#")]),a._v(" 二叉树（Binary Tree）")]),a._v(" "),t("p",[a._v("二叉树是一种特殊的树，它的每个节点最多只有两个子节点。二叉树可以用于表示表达式、Huffman编码等场景。")]),a._v(" "),t("h4",{attrs:{id:"二叉搜索树-binary-search-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树-binary-search-tree"}},[a._v("#")]),a._v(" 二叉搜索树（Binary Search Tree）")]),a._v(" "),t("p",[a._v("二叉搜索树是一种二叉树，它的左子树中所有节点的值都小于当前节点的值，右子树中所有节点的值都大于当前节点的值。由于这种特性，二叉搜索树支持快速的查找、插入和删除操作，时间复杂度为O(log n)。")]),a._v(" "),t("h3",{attrs:{id:"图-graph"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图-graph"}},[a._v("#")]),a._v(" 图（Graph）")]),a._v(" "),t("p",[a._v("图是一种非线性数据结构，它由节点和边组成。节点表示数据元素，边表示节点之间的关系。图可以表示任何复杂的关系，包括网络、社交关系等。图的节点和边可以具有各种属性，例如权重、方向等。")]),a._v(" "),t("h4",{attrs:{id:"有向图-directed-graph"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有向图-directed-graph"}},[a._v("#")]),a._v(" 有向图（Directed Graph）")]),a._v(" "),t("p",[a._v("有向图是一种图，它的边具有方向。有向图常用于表示依赖关系、流程图等场景。")]),a._v(" "),t("h4",{attrs:{id:"无向图-undirected-graph"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无向图-undirected-graph"}},[a._v("#")]),a._v(" 无向图（Undirected Graph）")]),a._v(" "),t("p",[a._v("无向图是一种图，它的边没有方向。无向图常用于表示社交关系、物理系统等场景。")]),a._v(" "),t("h4",{attrs:{id:"加权图-weighted-graph"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加权图-weighted-graph"}},[a._v("#")]),a._v(" 加权图（Weighted Graph）")]),a._v(" "),t("p",[a._v("加权图是一种图，它的边具有权重。加权图可以用于表示距离、成本等概念。")]),a._v(" "),t("h3",{attrs:{id:"哈希表-hash-table"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哈希表-hash-table"}},[a._v("#")]),a._v(" 哈希表（Hash Table）")]),a._v(" "),t("p",[a._v("哈希表是一种使用哈希函数将值映射到索引的数据结构。哈希表的插入、删除、查找操作的时间复杂度为O(1)，在某些情况下比树更高效。但是，哈希表对于哈希函数的选择、哈希冲突的处理等问题需要进行设计和优化。")]),a._v(" "),t("h3",{attrs:{id:"堆-heap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆-heap"}},[a._v("#")]),a._v(" 堆（Heap）")]),a._v(" "),t("p",[a._v("堆是一种基于完全二叉树的数据结构，它可以实现高效的插入、删除、查找最大/小值等操作。堆分为最大堆和最小堆两种形式，最大堆中每个节点的值都大于等于其子节点的值，最小堆中每个节点的值都小于等于其子节点的值。堆常用于优先级队列、排序等场景。")]),a._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("p",[a._v("以上是常见的数据结构，不同的数据结构对于不同的应用场景有不同的优缺点，选择合适的数据结构可以提高程序的效率和可维护性。在实际开发中，通常需要综合考虑数据结构的时间复杂度、空间复杂度、代码实现难度、易读性等因素，并进行权衡和取舍。")])])}),[],!1,null,null,null);t.default=s.exports}}]);