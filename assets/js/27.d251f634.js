(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{492:function(t,a,e){"use strict";e.r(a);var r=e(2),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("Reat知识点总结")])]),a("h2",{attrs:{id:"react中文官方文档"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react中文官方文档"}},[t._v("#")]),t._v(" React中文官方文档")]),t._v(" "),a("h3",{attrs:{id:"点击跳转"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#点击跳转"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://react.docschina.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击跳转"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"基础概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础概念"}},[t._v("#")]),t._v(" 基础概念")]),t._v(" "),a("h3",{attrs:{id:"组件-component"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件-component"}},[t._v("#")]),t._v(" 组件（Component）")]),t._v(" "),a("ul",[a("li",[t._v("React中最基本的概念")]),t._v(" "),a("li",[t._v("组件是构建UI界面的基础单元，可以将一个大型的应用程序拆分成多个小组件")]),t._v(" "),a("li",[t._v("组件可以是函数组件或类组件")])]),t._v(" "),a("h3",{attrs:{id:"属性-props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性-props"}},[t._v("#")]),t._v(" 属性（Props）")]),t._v(" "),a("ul",[a("li",[t._v("Props 是从父组件传递给子组件的数据，是只读的")]),t._v(" "),a("li",[t._v("可以通过 props 在组件之间传递数据")])]),t._v(" "),a("h3",{attrs:{id:"状态-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态-state"}},[t._v("#")]),t._v(" 状态（State）")]),t._v(" "),a("ul",[a("li",[t._v("State 是组件内部管理的状态，可以通过 setState 方法改变")]),t._v(" "),a("li",[t._v("修改状态会触发组件重新渲染")])]),t._v(" "),a("h3",{attrs:{id:"生命周期-lifecycle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期-lifecycle"}},[t._v("#")]),t._v(" 生命周期（Lifecycle）")]),t._v(" "),a("ul",[a("li",[t._v("生命周期是组件从创建到销毁过程中所经历的各个阶段")]),t._v(" "),a("li",[t._v("每个阶段都有对应的生命周期方法，在不同的时刻执行相应的操作")]),t._v(" "),a("li",[t._v("常用的生命周期方法有：componentDidMount、componentDidUpdate、componentWillUnmount等")])]),t._v(" "),a("h2",{attrs:{id:"jsx语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx语法"}},[t._v("#")]),t._v(" JSX语法")]),t._v(" "),a("h3",{attrs:{id:"什么是jsx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是jsx"}},[t._v("#")]),t._v(" 什么是JSX")]),t._v(" "),a("ul",[a("li",[t._v("JSX 是一种 JavaScript 的语法扩展")]),t._v(" "),a("li",[t._v("它允许我们在 JavaScript 中编写类似 HTML 的代码")])]),t._v(" "),a("h3",{attrs:{id:"jsx特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx特点"}},[t._v("#")]),t._v(" JSX特点")]),t._v(" "),a("ul",[a("li",[t._v("与模板语言相比，JSX更加灵活和强大")]),t._v(" "),a("li",[t._v("JSX 具有 JavaScript 表达式的能力")]),t._v(" "),a("li",[t._v("JSX 不需要学习新的模板语言，学习曲线相对较低")])]),t._v(" "),a("h3",{attrs:{id:"jsx基础语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx基础语法"}},[t._v("#")]),t._v(" JSX基础语法")]),t._v(" "),a("ul",[a("li",[t._v("使用 {} 将 JavaScript 表达式包裹起来")]),t._v(" "),a("li",[t._v("使用 className 替代 class")]),t._v(" "),a("li",[t._v("使用 htmlFor 替代 for")])]),t._v(" "),a("h2",{attrs:{id:"组件交互"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件交互"}},[t._v("#")]),t._v(" 组件交互")]),t._v(" "),a("h3",{attrs:{id:"事件处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件处理"}},[t._v("#")]),t._v(" 事件处理")]),t._v(" "),a("ul",[a("li",[t._v("通过绑定事件监听器，在特定的事件触发时执行相应的代码")]),t._v(" "),a("li",[t._v("可以使用箭头函数或 bind 方法绑定 this")])]),t._v(" "),a("h3",{attrs:{id:"组件通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件通信"}},[t._v("#")]),t._v(" 组件通信")]),t._v(" "),a("ul",[a("li",[t._v("父子组件通信：通过 Props 传递数据")]),t._v(" "),a("li",[t._v("子父组件通信：通过回调函数实现子组件向父组件传递数据")]),t._v(" "),a("li",[t._v("跨级组件通信：使用 Context，在组件树中进行跨级传递数据")])]),t._v(" "),a("h3",{attrs:{id:"refs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#refs"}},[t._v("#")]),t._v(" Refs")]),t._v(" "),a("ul",[a("li",[t._v("Refs 提供了一种方式，允许我们直接访问 DOM 元素或组件实例")]),t._v(" "),a("li",[t._v("可以通过 React.createRef 或回调函数方式创建 Refs")])]),t._v(" "),a("h2",{attrs:{id:"react高级特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react高级特性"}},[t._v("#")]),t._v(" React高级特性")]),t._v(" "),a("h3",{attrs:{id:"高阶组件-higher-order-component"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件-higher-order-component"}},[t._v("#")]),t._v(" 高阶组件（Higher Order Component）")]),t._v(" "),a("ul",[a("li",[t._v("HOC 是一个函数，接收一个组件作为参数并返回一个新的组件")]),t._v(" "),a("li",[t._v("可以让我们复用组件逻辑，增强组件的功能")])]),t._v(" "),a("h3",{attrs:{id:"render-props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-props"}},[t._v("#")]),t._v(" Render Props")]),t._v(" "),a("ul",[a("li",[t._v("Render Props 是一个使用函数作为子组件的一种技术")]),t._v(" "),a("li",[t._v("通过 props 将一个函数传递给另一个组件，使得后者可以调用该函数，并获取其返回值")])]),t._v(" "),a("h3",{attrs:{id:"hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[t._v("#")]),t._v(" Hooks")]),t._v(" "),a("ul",[a("li",[t._v("Hooks 是 React v16.8 引入的新特性，提供了对函数组件中状态管理和副作用处理的支持")]),t._v(" "),a("li",[t._v("常用的几个 Hooks 分别为 useState、useEffect 和 useContext 等")])]),t._v(" "),a("h2",{attrs:{id:"react路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react路由"}},[t._v("#")]),t._v(" React路由")]),t._v(" "),a("h3",{attrs:{id:"react-router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-router"}},[t._v("#")]),t._v(" React Router")]),t._v(" "),a("ul",[a("li",[t._v("React Router 是 React 中最流行的路由库")]),t._v(" "),a("li",[t._v("可以帮助我们实现SPA（Single Page Application）应用程序的路由管理")]),t._v(" "),a("li",[t._v("常用的组件有：BrowserRouter、Route、Link 和 Redirect 等")])]),t._v(" "),a("h3",{attrs:{id:"动态路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态路由"}},[t._v("#")]),t._v(" 动态路由")]),t._v(" "),a("ul",[a("li",[t._v("动态路由是指通过 URL 参数来告诉应用程序需要显示哪些内容")]),t._v(" "),a("li",[t._v("可以通过 React Router 实现动态路由，使用 :parameter 格式来定义动态路由参数")])]),t._v(" "),a("h2",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),a("h3",{attrs:{id:"redux基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux基础"}},[t._v("#")]),t._v(" Redux基础")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Redux 是一种状态管理库，用于管理整个应用程序的状态")])]),t._v(" "),a("li",[a("p",[t._v("Redux 的核心概念包括 store、action 和 reducer 等")])]),t._v(" "),a("li",[a("p",[t._v("Redux 的工作流程大致为：用户交互 -> 触发 action -> reducer 修改状态 -> UI更新")])]),t._v(" "),a("li",[a("p",[t._v("Redux 的工作流程大致为：用户交互 -> 触发 action -> reducer 修改状态 -> UI 重新渲染")])])]),t._v(" "),a("h3",{attrs:{id:"redux进阶"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux进阶"}},[t._v("#")]),t._v(" Redux进阶")]),t._v(" "),a("ul",[a("li",[t._v("Redux 中间件（Middleware）是指在 action 被发送到 reducer 前进行一些额外的处理的函数")]),t._v(" "),a("li",[t._v("常用的中间件有：thunk、saga 和 logger 等")]),t._v(" "),a("li",[t._v("Redux Toolkit 是一个官方提供的工具集，可以简化 Redux 应用程序开发过程")])]),t._v(" "),a("h2",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),a("h3",{attrs:{id:"react性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react性能问题"}},[t._v("#")]),t._v(" React性能问题")]),t._v(" "),a("ul",[a("li",[t._v("React 应用程序的性能瓶颈通常出现在组件渲染上")]),t._v(" "),a("li",[t._v("不必要的重复渲染、不恰当的使用状态和 Props、缺乏异步加载等都会导致 React 应用程序性能下降")])]),t._v(" "),a("h3",{attrs:{id:"性能优化技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化技术"}},[t._v("#")]),t._v(" 性能优化技术")]),t._v(" "),a("ul",[a("li",[t._v("使用 React.memo 函数或 PureComponent 组件减少重复渲染")]),t._v(" "),a("li",[t._v("对 Props 进行浅比较或使用 immutability-helper 等库避免不必要的 Props 更新")]),t._v(" "),a("li",[t._v("使用 shouldComponentUpdate 生命周期方法避免不必要的组件渲染")]),t._v(" "),a("li",[t._v("使用懒加载或代码分割技术以达到更快的应用程序启动时间")]),t._v(" "),a("li",[t._v("使用 React Profiler 检查应用程序性能问题")])]),t._v(" "),a("h2",{attrs:{id:"其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),a("h3",{attrs:{id:"受控组件与非受控组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#受控组件与非受控组件"}},[t._v("#")]),t._v(" 受控组件与非受控组件")]),t._v(" "),a("ul",[a("li",[t._v("受控组件是指由 React 控制输入元素的值和状态的组件")]),t._v(" "),a("li",[t._v("非受控组件是指由 DOM 控制输入元素的值和状态的组件")])]),t._v(" "),a("h3",{attrs:{id:"自定义hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义hooks"}},[t._v("#")]),t._v(" 自定义Hooks")]),t._v(" "),a("ul",[a("li",[t._v("自定义 Hooks 可以让我们重用组件逻辑")]),t._v(" "),a("li",[t._v("自定义 Hooks 通常以 use 命名开头，并且只能在函数组件中使用")])]),t._v(" "),a("h3",{attrs:{id:"服务器渲染-ssr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务器渲染-ssr"}},[t._v("#")]),t._v(" 服务器渲染（SSR）")]),t._v(" "),a("ul",[a("li",[t._v("服务器渲染（Server Side Rendering）是指在服务器上将 React 组件渲染成 HTML 字符串再返回给客户端")]),t._v(" "),a("li",[t._v("SSR 可以加速应用程序的首次加载，同时也有助于 SEO（Search Engine Optimization）")]),t._v(" "),a("li",[t._v("常用的服务器渲染框架有：Next.js 和 Gatsby 等更新")])]),t._v(" "),a("h3",{attrs:{id:"typescript与react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript与react"}},[t._v("#")]),t._v(" TypeScript与React")]),t._v(" "),a("ul",[a("li",[t._v("TypeScript 是一种类型化的 JavaScript 超集，为 React 应用程序提供了更好的类型检查和编写代码提示")]),t._v(" "),a("li",[t._v("在 React 中使用 TypeScript 可以帮助我们更早地发现潜在的类型错误，提高代码的可维护性和稳定性")])]),t._v(" "),a("h3",{attrs:{id:"css-in-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css-in-js"}},[t._v("#")]),t._v(" CSS in JS")]),t._v(" "),a("ul",[a("li",[t._v("CSS in JS 是将 CSS 样式直接写在 JavaScript 代码中的一种技术")]),t._v(" "),a("li",[t._v("CSS in JS 提供了更加灵活的样式管理方式，可以避免 CSS 类名冲突等问题")]),t._v(" "),a("li",[t._v("常用的 CSS in JS 库有：styled-components、emotion 和 JSS 等")])]),t._v(" "),a("h3",{attrs:{id:"react-native"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-native"}},[t._v("#")]),t._v(" React Native")]),t._v(" "),a("ul",[a("li",[t._v("React Native 是 Facebook 推出的一种跨平台移动应用开发框架")]),t._v(" "),a("li",[t._v("使用 React Native 可以使用 JavaScript 编写原生 iOS 和 Android 应用程序")]),t._v(" "),a("li",[t._v("React Native 具有高度的可重用性和可测试性，可以大大提高移动应用开发效率")])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("以上就是 React 的基础知识点总结，包括组件、Props、State、生命周期、JSX 语法、事件处理、组件通信、Refs、高阶组件、Render Props、Hooks、React Router、Redux、性能优化、受控组件与非受控组件、自定义 Hooks、服务器渲染、TypeScript 与 React、CSS in JS 和 React Native。掌握这些知识点，可以让我们更好地使用 React 开发应用程序，提高代码质量和开发效率。")])])}),[],!1,null,null,null);a.default=s.exports}}]);